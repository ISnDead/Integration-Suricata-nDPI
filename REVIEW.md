# Code Review: Integration-Suricata-nDPI

## Замечания (по убыванию критичности)

### Высокая

1) Несовпадение API клиента и хост‑агента
- Доказательство: `pkg/agentclient/client.go:16` ожидает поля `ok`/`message`, а `post()` проверяет `out.OK` (`pkg/agentclient/client.go:62-67`).
- Доказательство: сервер отдаёт `ndpiToggleResp` без `ok`/`message` (`pkg/hostagent/handlers.go:29-32,68-92`), а ошибки возвращает plain text через `http.Error` (`pkg/hostagent/handlers.go:55-64,78-87`).
- Влияние: клиент будет считать успешные ответы ошибкой (по умолчанию `out.OK == false`) и упадёт на JSON‑декодировании ошибок.
- Рекомендация: унифицировать схему ответа. Либо сервер всегда возвращает `{ok, message, changed, enabled}` и JSON‑ошибки, либо клиент читает статус‑код и допускает текущую схему. Добавить интеграционные тесты на совместимость клиента/сервера.

2) Выбор кандидата сокета может остановиться на не‑сокете
- Доказательство: `integration/paths.go:9-15` возвращает первый существующий путь без проверки типа. `EnsureSuricataRunning` падает, если это не сокет (`integration/service_manager.go:12-29`), и не пробует следующий кандидат.
- Доказательство: `integration/connect_suricata.go:11-15` тоже использует `FirstExistingPath` и попытается dial'нуть обычный файл, если он существует.
- Влияние: если первый кандидат — обычный файл (устарел/ошибочно задан), валидные сокеты дальше игнорируются.
- Рекомендация: для выбора сокетов использовать функцию, которая проходит список и проверяет `os.ModeSocket` (или пробует `net.Dial`) перед выбором. `FirstExistingPath` оставить для не‑сокетных сценариев.

### Средняя

3) Команда reload передаётся как один аргумент
- Доказательство: `integration/apply_config.go:74` вызывает `exec.CommandContext(ctx, suricatascPath, "-c", reloadCommand)`.
- Влияние: если `reloadCommand` содержит пробелы/флаги (например, `"reload-rules --force"`), это будет один аргумент и `suricatasc` может отклонить.
- Рекомендация: хранить команду как список аргументов (например, `[]string` в конфиге) или аккуратно разбивать `strings.Fields` (с понятными правилами экранирования). Добавить тесты на многоаргументные команды.

4) Права файла suricata.yaml не сохраняются в ApplyConfig
- Доказательство: `integration/apply_config.go:60` пишет с фиксированными правами `0o644`.
- Доказательство: `integration/write_suricata_config.go:19-25` уже умеет сохранять текущие права файла.
- Влияние: более строгие права могут быть ослаблены, что является регрессией безопасности/операций.
- Рекомендация: перенести логику сохранения прав из `WriteSuricataConfigFromTemplate` в `ApplyConfig`.

5) Непоследовательная валидация reload timeout при отключённом reload
- Доказательство: `integration/apply_config.go:36-46` разрешает `reload_command` пустой/none и пропускает reload.
- Доказательство: `integration/validate_ndpi_config.go:74-86` и `internal/config/validate.go:26-28` запрещают `reload_timeout <= 0` независимо от `reload_command`.
- Влияние: конфиг, который намеренно выключает reload, не может выставить timeout в 0, хотя runtime его игнорирует.
- Рекомендация: разрешить `reload_timeout <= 0`, когда `reload_command` пустой/none, либо зафиксировать требование в документации и enforce‑ить его в runtime.

6) Безусловное удаление unix‑сокета
- Доказательство: `pkg/hostagent/server.go:37` делает `os.Remove` без проверки типа.
- Влияние: при ошибочно заданном пути может быть удалён обычный файл.
- Рекомендация: проверять тип через `os.Stat` и удалять только сокет (или несуществующий путь), иначе возвращать понятную ошибку.

### Низкая

7) Поля конфига, которые не используются
- Доказательство: `internal/config/types.go:26-30` задаёт `apply.*`, но они нигде не применяются.
- Доказательство: `internal/config/types.go:37-40` задаёт `system.*`, дефолты выставляются (`internal/config/defaults.go:17-21`), но `systemctl` из конфига не используется (`pkg/hostagent/restart.go:20`, `integration/systemd_restart.go:24`).
- Влияние: пользователь может настроить параметры, которые не влияют на поведение, что вызывает путаницу.
- Рекомендация: либо подключить эти поля в runtime (использовать путь `systemctl`, apply‑флаги), либо удалить их и упростить конфиг.

8) README не описывает реальное использование
- Доказательство: `README.md:1-1` содержит заглушку.
- Влияние: ухудшается онбординг и эксплуатационная ясность.
- Рекомендация: добавить инструкцию по установке, конфигу и запуску (systemd‑unit, сокеты, шаблон Suricata).

## Вопросы / допущения
- `reload_command` всегда одно слово или может включать флаги/аргументы?
- `pkg/agentclient` реально используется для общения с `pkg/hostagent`?
- Нужна ли поддержка окружений без `systemctl` в `PATH`, раз в конфиге есть `system.systemctl`?

## Краткий итог (вторично)
- Выровнять контракт API клиента/сервера для NDPI toggle.
- Улучшить выбор сокета и сохранить права файлов.
- Прояснить семантику конфига и удалить/подключить неиспользуемые поля.
- Дополнить документацию.

---

## Архитектура и стиль (дополнительное ревью)

### Наблюдения по стилю и паттернам

1) Нет единой точки входа/жизненного цикла
- Доказательство: два отдельных `main` с разными стилями запуска, каждый сам инициализирует логгер/контекст/остановку (`cmd/integration/main.go:30-60`, `cmd/host-agent/main.go:15-75`).
- Влияние: расхождение поведения при старте/остановке, сложнее единообразно добавлять shutdown/health/metrics.
- Рекомендация: вынести общий bootstrap в пакет (например, `internal/app`), где есть единый `Run(ctx)` и общий lifecycle (init -> start -> wait -> stop).

2) Graceful shutdown реализован непоследовательно
- Доказательство: `integration.Runner` блокируется на `<-ctx.Done()` и вызывает `Stop()` (`integration/runner.go:49-60`), а `hostagent.Server.Start` сам следит за `ctx.Done()` и вызывает `Stop()` (`pkg/hostagent/server.go:66-89`).
- Влияние: разные модели остановки, при расширении функционала легко получить двойной stop или забыть закрыть ресурсы.
- Рекомендация: унифицировать контракт: например, все сервисы реализуют `Start(ctx)` и `Stop(ctx)` и управляются единым раннером/группой (errgroup).

3) Слабая абстракция зависимостей и инфраструктуры
- Доказательство: прямой вызов `os`, `exec`, `net` в бизнес‑коде (`integration/apply_config.go`, `integration/systemd_restart.go`, `pkg/hostagent/restart.go`).
- Влияние: сложнее тестировать и мокать; зависимости на окружение (systemd, файловая система) размазаны.
- Рекомендация: вынести интерфейсы (например, `FileSystem`, `CommandRunner`, `ServiceManager`, `SuricataClient`) и прокидывать их через конструкторы.

4) Дублирование инфраструктурной логики
- Доказательство: две функции `RestartUnit` с похожей реализацией (`pkg/hostagent/restart.go`, `integration/systemd_restart.go`).
- Влияние: риск рассинхронизации логики (логирование, timeouts, конфиг).
- Рекомендация: единый пакет управления systemd, повторное использование через интерфейс.

5) Разные уровни ответственности в пакетах
- Доказательство: `integration` содержит и orchestration, и низкоуровневые утилиты (atomic write, поиск пути, парсинг конфигурации Suricata).
- Влияние: пакет становится «мешком всего», сложно переиспользовать и тестировать.
- Рекомендация: разделить на `internal/infra` (FS/exec), `internal/suricata` (операции с конфигом), `internal/app` (workflow).

6) CLI интерфейс: флаги вместо команд/подкоманд
- Доказательство: оба `main` используют простые флаги (`cmd/integration/main.go:34-41`, `cmd/host-agent/main.go:20-33`).
- Влияние: расширять CLI неудобно, нет документации команд, сложно сделать dry-run, validate, status.
- Рекомендация: использовать полноценный CLI (например, cobra) с подкомандами: `validate`, `apply`, `status`, `serve`.

7) Провайдинг зависимостей вручную в main
- Доказательство: сборка зависимостей выполняется прямо в `main` (`cmd/host-agent/main.go:20-70`).
- Влияние: рост `main` и связей, сложнее менять/тестировать.
- Рекомендация: рассмотреть `wire` для DI (создание `Server`, `Runner`, конфиг‑лоадера, логгера, системных адаптеров).

### Рекомендации по улучшению архитектуры

1) Ввести единый жизненный цикл приложения
- Центральный `App` с методами `Start(ctx)`/`Stop(ctx)` и общей стратегией shutdown через `context` и `errgroup`.
- Единый логгер, метрики, health endpoints, обработка сигналов.

2) Разделить доменную и инфраструктурную части
- Домен: «конфиг Suricata», «toggle nDPI», «apply config».
- Инфра: filesystem, systemd, сокеты, выполнение команд.
- Это упростит тесты и переиспользование.

3) Ввести интерфейсы и DI
- Интерфейсы для `Systemd`, `SuricataControl`, `FileOps`, `Clock/Timers`.
- Сборка через `wire` либо явные конструкторы в `internal/app`.

4) Улучшить CLI опыт
- Подкоманды + единый config‑loading, `--config` как глобальный флаг.
- Команды для статуса/валидации и dry‑run.

5) Стандартизировать graceful shutdown
- Все сервисы должны закрывать файлы/сокеты/горутинные операции по одному протоколу.
- Явный timeout на shutdown и логирование результата.
